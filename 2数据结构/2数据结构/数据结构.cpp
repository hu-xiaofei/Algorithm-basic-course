#define _CRT_SECURE_NO_WARNINGS
#include<iostream>;
using namespace std;

//单链表

//const int N = 100010;  // 定义链表最大长度
//
//// 全局变量定义
//int head, e[N], ne[N], idx;
//// head - 头节点的下标
//// e[i] - 节点i存储的值
//// ne[i] - 节点i的next指针(存储下一个节点的下标)
//// idx - 当前可用的节点索引
//
//// 初始化链表
//void init()
//{
//    head = -1;  // 头节点初始为-1，表示空链表
//    idx = 0;    // 从0开始分配节点
//}
//
//// 在链表头部插入节点
//void add_to_head(int x)
//{
//    e[idx] = x;    // 存储值x到新节点
//    ne[idx] = head; // 新节点的next指向原头节点
//    head = idx;     // 更新头节点为新节点
//    idx++;          // 移动到下一个可用索引
//}
//
//// 在指定位置k后插入节点
//void add(int k, int x)
//{
//    e[idx] = x;        // 存储值x到新节点
//    ne[idx] = ne[k];    // 新节点的next指向k节点原来的next
//    ne[k] = idx;        // k节点的next指向新节点
//    idx++;              // 移动到下一个可用索引
//}
//
//// 删除指定位置k后的节点
//void remove(int k)
//{
//    ne[k] = ne[ne[k]];  // 将k节点的next指向k+2节点，相当于跳过了k+1节点
//}
//
//int main()
//{
//    int m;
//    cin >> m;  // 输入操作次数m
//
//    init();  // 初始化链表
//
//    while (m--)  // 循环处理m个操作
//    {
//        int k, x;
//        char op;
//
//        cin >> op;  // 输入操作类型
//        if (op == 'H')  // 如果操作是在头部插入
//        {
//            cin >> x;  // 输入要插入的值x
//            add_to_head(x);  // 调用头部插入函数
//        }
//        else if (op == 'D')  // 如果操作是删除
//        {
//            cin >> k;  // 输入要删除的位置k
//            if (!k) head = ne[head];  // 如果k为0，删除头节点
//            remove(k - 1);  // 否则删除第k-1个节点后面的节点(因为数组下标从0开始)
//        }
//        else  // 其他情况视为在指定位置插入
//        {
//            cin >> k >> x;  // 输入位置k和值x
//            add(k - 1, x);  // 在第k-1个节点后插入新节点
//        }
//    }
//
//    // 遍历并输出链表
//    for (int i = head; i != -1; i = ne[i]) cout << e[i] << ' ';
//    cout << endl;
//}

//双链表

////可以用结构体，但是比较复杂，不如直接用数组
//const int N = 100010;  // 定义链表最大容量
//
//int m;                 // 操作次数
//int e[N], l[N], r[N],  // e[]存储节点值，l[]存储左指针，r[]存储右指针
//int idx;               // 当前可用的节点索引
//
//// 初始化双链表
//void init()
//{
//    // 使用两个哨兵节点：0号节点作为左端点，1号节点作为右端点
//    // 初始时，0号节点的右指针指向1号节点
//    // 1号节点的左指针指向0号节点
//    r[0] = 1, l[1] = 0;
//    idx = 2;  // 前两个索引(0和1)已被占用，从2开始分配新节点
//}
//
//// 在节点k的右侧插入一个值为x的新节点
//void add(int k, int x)
//{
//    e[idx] = x;     // 存储值x到新节点
//    r[idx] = r[k];  // 新节点的右指针指向k节点原来的右节点
//    l[idx] = k;     // 新节点的左指针指向k节点
//    l[r[k]] = idx;  // k节点原来右节点的左指针指向新节点
//    r[k] = idx;     // k节点的右指针指向新节点
//    idx++;          // 移动到下一个可用索引
//}
//
//// 删除节点k
//void remove(int k)
//{
//    r[l[k]] = r[k];  // k节点左节点的右指针指向k的右节点
//    l[r[k]] = l[k];  // k节点右节点的左指针指向k的左节点
//}

//栈

//const int N = 100010;  // 定义栈的最大容量
//
//int stk[N],  // 用于存储栈元素的数组
//	tt;      // 栈顶指针（top pointer），指向当前栈顶元素的位置
//
//// 插入元素（入栈操作）
//stk[++tt] = x;
//// 1. 先将栈顶指针tt加1（前++操作）
//// 2. 然后将元素x存储到新的栈顶位置
//// 相当于：tt = tt + 1; stk[tt] = x;
//
//// 弹出元素（出栈操作）
//tt--;
//// 简单地将栈顶指针减1
//// 虽然原数据仍在数组中，但不再被视为栈的一部分
//
//// 判断栈是否为空
//if (tt > 0) not empty  // 栈不为空
//else empty             // 栈为空
//// 当tt > 0时表示栈中有元素
//// 当tt == 0时表示栈为空（因为插入时是先++再赋值）
//
//// 获取栈顶元素
//stk[tt];
//// 直接返回栈顶指针指向的元素
//// 注意：在访问前应该先检查栈是否为空

//队列、

//// 定义队列数组和指针
//int q[N],     // 用于存储队列元素的数组
//hh,       // 队头指针（head），指向队列第一个元素
//tt = -1;  // 队尾指针（tail），指向队列最后一个元素，初始化为-1表示空队列
//
//// 在队尾插入元素（入队操作）
//q[++tt] = x;
//// 1. 先将队尾指针tt加1（前++操作）
//// 2. 然后将元素x存储到新的队尾位置
//// 例如：初始tt=-1，插入第一个元素后tt=0，元素存储在q[0]
//
//// 在队头弹出元素（出队操作）
//hh++;
//// 简单地将队头指针加1
//// 虽然原数据仍在数组中，但不再被视为队列的一部分
//
//// 判断队列是否为空
//if (hh <= tt) not empty  // 队列不为空（队头指针<=队尾指针）
//else empty               // 队列为空
//// 当hh > tt时表示队列中没有元素
//
//// 取出队头元素（不删除）
//q[hh]
//// 直接返回队头指针指向的元素
//// 注意：在访问前应该先检查队列是否为空

//单调栈――――寻找每个元素左边第一个比它小的数

//const int N = 100010;  // 定义最大数据量
//
//int n;                 // 输入的元素个数
//int stk[N], tt;        // 栈数组和栈顶指针(初始tt=0)
//
//int main()
//{
//    scanf("%d", &n);   // 读取元素个数n
//
//    for (int i = 0; i < n; i++)  // 遍历每个元素
//    {
//        int x;
//        scanf("%d", &x);  // 读取当前元素x
//
//        // 维护单调递增栈：弹出所有大于等于当前x的元素
//        // 这样栈顶就是第一个小于x的元素
//        while (tt && stk[tt] >= x) tt--;
//
//        // 如果栈不为空，输出栈顶元素（左边第一个比x小的数）
//        if (tt) printf("%d ", stk[tt]);
//        // 否则输出-1（没有比x小的元素）
//        else printf("-1 ");
//
//        // 将当前元素x压入栈中
//        stk[++tt] = x;
//    }
//
//    return 0;
//}

//单调队列
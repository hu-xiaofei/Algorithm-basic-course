#define _CRT_SECURE_NO_WARNINGS
#include<iostream>;
using namespace std;

//单链表

//const int N = 100010;  // 定义链表最大长度
//
//// 全局变量定义
//int head, e[N], ne[N], idx;
//// head - 头节点的下标
//// e[i] - 节点i存储的值
//// ne[i] - 节点i的next指针(存储下一个节点的下标)
//// idx - 当前可用的节点索引
//
//// 初始化链表
//void init()
//{
//    head = -1;  // 头节点初始为-1，表示空链表
//    idx = 0;    // 从0开始分配节点
//}
//
//// 在链表头部插入节点
//void add_to_head(int x)
//{
//    e[idx] = x;    // 存储值x到新节点
//    ne[idx] = head; // 新节点的next指向原头节点
//    head = idx;     // 更新头节点为新节点
//    idx++;          // 移动到下一个可用索引
//}
//
//// 在指定位置k后插入节点
//void add(int k, int x)
//{
//    e[idx] = x;        // 存储值x到新节点
//    ne[idx] = ne[k];    // 新节点的next指向k节点原来的next
//    ne[k] = idx;        // k节点的next指向新节点
//    idx++;              // 移动到下一个可用索引
//}
//
//// 删除指定位置k后的节点
//void remove(int k)
//{
//    ne[k] = ne[ne[k]];  // 将k节点的next指向k+2节点，相当于跳过了k+1节点
//}
//
//int main()
//{
//    int m;
//    cin >> m;  // 输入操作次数m
//
//    init();  // 初始化链表
//
//    while (m--)  // 循环处理m个操作
//    {
//        int k, x;
//        char op;
//
//        cin >> op;  // 输入操作类型
//        if (op == 'H')  // 如果操作是在头部插入
//        {
//            cin >> x;  // 输入要插入的值x
//            add_to_head(x);  // 调用头部插入函数
//        }
//        else if (op == 'D')  // 如果操作是删除
//        {
//            cin >> k;  // 输入要删除的位置k
//            if (!k) head = ne[head];  // 如果k为0，删除头节点
//            remove(k - 1);  // 否则删除第k-1个节点后面的节点(因为数组下标从0开始)
//        }
//        else  // 其他情况视为在指定位置插入
//        {
//            cin >> k >> x;  // 输入位置k和值x
//            add(k - 1, x);  // 在第k-1个节点后插入新节点
//        }
//    }
//
//    // 遍历并输出链表
//    for (int i = head; i != -1; i = ne[i]) cout << e[i] << ' ';
//    cout << endl;
//}

//双链表

////可以用结构体，但是比较复杂，不如直接用数组
//const int N = 100010;  // 定义链表最大容量
//
//int m;                 // 操作次数
//int e[N], l[N], r[N],  // e[]存储节点值，l[]存储左指针，r[]存储右指针
//int idx;               // 当前可用的节点索引
//
//// 初始化双链表
//void init()
//{
//    // 使用两个哨兵节点：0号节点作为左端点，1号节点作为右端点
//    // 初始时，0号节点的右指针指向1号节点
//    // 1号节点的左指针指向0号节点
//    r[0] = 1, l[1] = 0;
//    idx = 2;  // 前两个索引(0和1)已被占用，从2开始分配新节点
//}
//
//// 在节点k的右侧插入一个值为x的新节点
//void add(int k, int x)
//{
//    e[idx] = x;     // 存储值x到新节点
//    r[idx] = r[k];  // 新节点的右指针指向k节点原来的右节点
//    l[idx] = k;     // 新节点的左指针指向k节点
//    l[r[k]] = idx;  // k节点原来右节点的左指针指向新节点
//    r[k] = idx;     // k节点的右指针指向新节点
//    idx++;          // 移动到下一个可用索引
//}
//
//// 删除节点k
//void remove(int k)
//{
//    r[l[k]] = r[k];  // k节点左节点的右指针指向k的右节点
//    l[r[k]] = l[k];  // k节点右节点的左指针指向k的左节点
//}

//栈

//const int N = 100010;  // 定义栈的最大容量
//
//int stk[N],  // 用于存储栈元素的数组
//	tt;      // 栈顶指针（top pointer），指向当前栈顶元素的位置
//
//// 插入元素（入栈操作）
//stk[++tt] = x;
//// 1. 先将栈顶指针tt加1（前++操作）
//// 2. 然后将元素x存储到新的栈顶位置
//// 相当于：tt = tt + 1; stk[tt] = x;
//
//// 弹出元素（出栈操作）
//tt--;
//// 简单地将栈顶指针减1
//// 虽然原数据仍在数组中，但不再被视为栈的一部分
//
//// 判断栈是否为空
//if (tt > 0) not empty  // 栈不为空
//else empty             // 栈为空
//// 当tt > 0时表示栈中有元素
//// 当tt == 0时表示栈为空（因为插入时是先++再赋值）
//
//// 获取栈顶元素
//stk[tt];
//// 直接返回栈顶指针指向的元素
//// 注意：在访问前应该先检查栈是否为空

//队列、

//// 定义队列数组和指针
//int q[N],     // 用于存储队列元素的数组
//hh,       // 队头指针（head），指向队列第一个元素
//tt = -1;  // 队尾指针（tail），指向队列最后一个元素，初始化为-1表示空队列
//
//// 在队尾插入元素（入队操作）
//q[++tt] = x;
//// 1. 先将队尾指针tt加1（前++操作）
//// 2. 然后将元素x存储到新的队尾位置
//// 例如：初始tt=-1，插入第一个元素后tt=0，元素存储在q[0]
//
//// 在队头弹出元素（出队操作）
//hh++;
//// 简单地将队头指针加1
//// 虽然原数据仍在数组中，但不再被视为队列的一部分
//
//// 判断队列是否为空
//if (hh <= tt) not empty  // 队列不为空（队头指针<=队尾指针）
//else empty               // 队列为空
//// 当hh > tt时表示队列中没有元素
//
//// 取出队头元素（不删除）
//q[hh]
//// 直接返回队头指针指向的元素
//// 注意：在访问前应该先检查队列是否为空

//单调栈――――寻找每个元素左边第一个比它小的数

//const int n = 100010;  // 定义最大数据量
//
//int n;                 // 输入的元素个数
//int stk[n], tt;        // 栈数组和栈顶指针(初始tt=0)
//
//int main()
//{
//    scanf("%d", &n);   // 读取元素个数n
//
//    for (int i = 0; i < n; i++)  // 遍历每个元素
//    {
//        int x;
//        scanf("%d", &x);  // 读取当前元素x
//
//        // 维护单调递增栈：弹出所有大于等于当前x的元素
//        // 这样栈顶就是第一个小于x的元素
//        while (tt && stk[tt] >= x) tt--;
//
//        // 如果栈不为空，输出栈顶元素（左边第一个比x小的数）
//        if (tt) printf("%d ", stk[tt]);
//        // 否则输出-1（没有比x小的元素）
//        else printf("-1 ");
//
//        // 将当前元素x压入栈中
//        stk[++tt] = x;
//    }
//
//    return 0;
//}

//单调队列――――滑动窗口求最大最小值

//const int N = 1000010;  // 定义数组的最大长度
//
//int n, k;       // n: 数组长度, k: 窗口大小
//int a[N], q[N]; // a: 存储输入数组, q: 单调队列(存储的是下标)
//
//int main()
//{
//    scanf("%d%d", &n, &k);  // 读取数组长度n和窗口大小k
//    for (int i = 0; i < n; i++) scanf("%d", &a[i]); // 读取数组元素
//
//    // 第一部分：求滑动窗口最小值
//    int hh = 0, tt = -1; // 初始化队列头(hh)和尾(tt)指针
//    for (int i = 0; i < n; i++)
//    {
//        // 如果队列不为空（hh <= tt）且队头元素已不在当前窗口内（i - k + 1 > q[hh]），则移动队头指针
//        if (hh <= tt && i - k + 1 > q[hh]) hh++;
//
//        // 当队列不为空（hh <= tt）且队尾元素大于等于当前元素时，弹出队尾
//        while (hh <= tt && a[q[tt]] >= a[i]) tt--;
//
//        q[++tt] = i; // 将当前元素下标加入队尾
//
//        // 当窗口形成时(即i >= k-1)，输出（如果窗口小于k，则不输出）
//        if (i >= k - 1) printf("%d ", a[q[hh]]);
//    }
//    puts(""); // 输出换行
//
//    // 第二部分：求滑动窗口最大值
//    hh = 0, tt = -1; // 重新初始化队列
//    for (int i = 0; i < n; i++)
//    {
//        // 同上，判断队头是否滑出窗口
//        if (hh <= tt && i - k + 1 > q[hh]) hh++;
//
//        // 维护单调递减队列
//        // 当队列不为空且队尾元素小于等于当前元素时，弹出队尾
//        while (hh <= tt && a[q[tt]] <= a[i]) tt--;
//
//        q[++tt] = i; // 将当前元素下标加入队尾
//
//        // 当窗口形成时，输出当前窗口最大值(队头元素)
//        if (i >= k - 1) printf("%d ", a[q[hh]]);
//    }
//    puts(""); // 输出换行
//
//    return 0;
//}

//KMP算法

//#include <iostream>
//using namespace std;
//
//const int N = 10010, M = 100010;  // 定义数组大小常量，N是模式串最大长度，M是主串最大长度
//int n, m;                         // n-模式串长度，m-主串长度
//char p[N], s[M];                   // p-模式串，s-主串（都从下标1开始存储）
//int ne[N];                         // next数组，用于KMP算法,（直接写next[]可能会报错）
//
//int main()
//{
//    // 输入数据：模式串长度n，模式串p（从p[1]开始存储），主串长度m，主串s（从s[1]开始存储）
//    cin >> n >> p + 1 >> m >> s + 1;
//
//    // 构建next数组的过程（预处理模式串）
//    for (int i = 2, j = 0; i <= n; i++)
//    {
//        // 当j不为0且当前字符不匹配时，回退j到ne[j]
//        while (j && p[i] != p[j + 1]) j = ne[j];
//        // 如果当前字符匹配，j向前移动
//        if (p[i] == p[j + 1]) j++;
//        // 记录当前位置i的next值
//        ne[i] = j;
//    }
//
//    // KMP匹配过程
//    for (int i = 1, j = 0; i <= m; i++)
//    {
//        // 当j不为0且当前字符不匹配时，利用next数组回退j
//        while (j && s[i] != p[j + 1]) j = ne[j];
//        // 如果当前字符匹配，j向前移动
//        if (s[i] == p[j + 1]) j++;
//        // 如果j等于模式串长度n，说明找到完整匹配
//        if (j == n)
//        {
//            // 输出匹配的起始位置（从0开始计数）
//            printf("%d ", i - n);
//            // 回退j以继续寻找其他可能的匹配
//            j = ne[j];
//        }
//    }
//
//    return 0;
//}

//Trie

//Trie:高效地存储和查找字符串集合的数据结构
const int N = 100010;  // 定义Trie树的最大节点数量

int son[N][26], cnt[N], idx;
// son[N][26]: 每个节点最多有26个子节点（对应26个小写字母）
// cnt[N]: 以当前节点结尾的单词数量
// idx: 当前可用的节点编号（从1开始分配）

//插入操作
void insert(char str[])
{
    int p = 0;  // 从根节点开始（根节点编号为0）
    for (int i = 0; str[i]; i++)  // 遍历字符串中的每个字符
    {
        int u = str[i] - 'a';  // 将字符转换为0-25的数字（a-z）
        if (!son[p][u]) son[p][u] = ++idx;  // 如果不存在对应子节点，则创建新节点
        p = son[p][u];  // 移动到子节点
    }
    cnt[p]++;  // 标记单词结束，增加计数器
}

//查询操作
int query(char str[])
{
    int p = 0;  // 从根节点开始
    for (int i = 0; str[i]; i++)  // 遍历字符串中的每个字符
    {
        int u = str[i] - 'a';  // 将字符转换为0-25的数字
        if (!son[p][u]) return 0;  // 如果路径不存在，返回0（表示没找到）
        p = son[p][u];  // 移动到子节点
    }
    return cnt[p];  // 返回以该节点结尾的单词数量
}

int main()
{
    int n;
    scanf("%d", &n);  // 输入操作数量
    while (n--)
    {
        char op[2];
        char str[N];  // 这里代码中缺少str的定义，实际应该添加
        scanf("%s%s", op, str);  // 输入操作类型和字符串
        if (op[0] == 'I') insert(str);  // 插入操作
        else printf("%d\n", query(str));  // 查询操作并输出结果
    }
    return 0;
}